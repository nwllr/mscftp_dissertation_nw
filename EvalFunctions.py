import numpy as npimport pandas as pdfrom sklearn.metrics import mean_squared_error, mean_absolute_errorfrom datetime import datetimedef add_quintiles(df, name='Quintile'):    """    Adds a new column to the dataframe containing quintile ranks based on the 'Mispricing' column.    Parameters:    df (pd.DataFrame): DataFrame to which the quintile column will be added. It must contain a 'Mispricing' column.    name (str): The name for the new quintile column. Defaults to 'Quintile'.    Returns:    df (pd.DataFrame): DataFrame with the new quintile column added.    Raises:    ValueError: If 'Mispricing' column is not found in df.    """        if 'Mispricing' not in df.columns:        raise ValueError("Please ensure that a 'Mispricing' column exists in the dataframe")            # Rank the mispricing signal    ranked_signal = df['Mispricing'].rank(pct=True)    # Assign a quintile based on the relative ranking    class_labels = [1, 2, 3, 4, 5]    class_cutoffs = np.percentile(ranked_signal, np.linspace(0, 100, len(class_labels) + 1))        if len(set(class_cutoffs)) < len(class_cutoffs):        df[name] = np.nan    else:        df[name] = pd.cut(ranked_signal, class_cutoffs, labels=class_labels)            return dfdef evaluate_quintile_returns(model, Xtst, Ytst, log_transformed=False, save_eval_df=False, name=""):    """    Evaluates the quintile returns for a given model and test set, potentially saves the results as a CSV file.    Parameters:    model (model object): The trained model to be evaluated.    Xtst (pd.DataFrame): The test set to be used for the evaluation.    log_transformed (bool): Indicates if the target variable was log-transformed. Defaults to False.    save_eval_df (bool): Indicates if the evaluation DataFrame should be saved. Defaults to False.    name (str): Name of the file to save the evaluation DataFrame. It is ignored if save_eval_df is False.    Returns:    return_summary (pd.DataFrame): DataFrame summarizing the mean returns for each quintile.    Raises:    AssertionError: If the number of quintile groups is not 5.    """        if log_transformed:        Ytst_pred_log = model.predict(Xtst)        Ytst_pred = np.exp(Ytst_pred_log)        rmse = mean_squared_error(Ytst, Ytst_pred, squared=False)        mae = mean_absolute_error(Ytst, Ytst_pred)    else:        Ytst_pred = model.predict(Xtst)        rmse = mean_squared_error(Ytst, Ytst_pred, squared=False)        mae = mean_absolute_error(Ytst, Ytst_pred)            testset_eval = pd.DataFrame(Ytst)    testset_eval['pred'] = Ytst_pred    testset_eval['Mispricing'] = (testset_eval['pred'] - testset_eval['Company Market Cap']) / testset_eval['Company Market Cap']    add_quintiles(testset_eval, name='Quintile')    next_return_df = pd.read_csv('data/next_returns.csv', index_col=0, parse_dates=[2])    next_return_df['Date'] = next_return_df['Date'].dt.to_period('M')    testset_eval = pd.merge(testset_eval, next_return_df, on=['Date', 'tic'], how='left')    return_summary = testset_eval[['Quintile', 'Mispricing', 'Next 1M Return', 'Next 6M Return', 'Next 12M Return']].groupby('Quintile').mean()        assert return_summary.shape[0] == 5, f"Error: Expected 5 groups but got {return_summary.shape[0]} groups."    if save_eval_df:        testset_eval.to_csv(f'model_evaluations_1/{name}.csv')                print("Test Set (2019-2023)")        print("Root Mean Squared Error:", round(rmse/1000000000, 2), "Billion USD")        print("Mean Absolute Error:", round(mae/1000000000, 2), "Billion USD")                        with open('model_evaluations_4/valuation_accuracy', 'a') as file:            file.write('\n' + 80*'#')            file.write(f"\n\nTIMESTAMP: {datetime.now()}\n")            file.write(f"MODEL: {name}\n\n")            file.write("Test Set (2019-2023)")            file.write(f"\nRoot Mean Squared Error: {(rmse/1000000000):.2f} Billion USD")            file.write(f"\nMean Absolute Error: {(mae/1000000000):.2f} Billion USD\n")        return return_summarydef evaluate_quintile_returns_multiples(df, save_eval_df=False, name=""):    """    Returns evaluation summary for the multiple valuation and saves evaluation_df when save_eval_df is set to True.        With the PE ratio (share price/earnings per share) and the PE industry multiple, the     mispricing can be calculated in a similar fashion to the market capitalisation as in     the main experiment: If a company's PE ratio is higher than the industry average     PE multiple, the company can be seen as overvalued and the other way around.    """        if 'Trailing PE' not in df.columns or 'pe_exi' not in df.columns:        raise ValueError("Please ensure that a 'pe_exi' and 'Trailing PE' columns exists in the dataframe")        df['Mispricing'] = (df['Trailing PE'] - df['pe_exi']) / df['pe_exi']    add_quintiles(df, name='Quintile')    next_return_df = pd.read_csv('data/next_returns.csv', index_col=0, parse_dates=[2])    next_return_df['Date'] = next_return_df['Date'].dt.to_period('M')    df = pd.merge(df, next_return_df, on=['Date', 'tic'], how='left')    return_summary = df[['Quintile', 'Mispricing', 'Next 1M Return', 'Next 6M Return', 'Next 12M Return']].groupby('Quintile').mean()        if save_eval_df:        df.to_csv(f'model_evaluations_1/{name}.csv')        return_summary.to_csv(f'model_evaluations_2/{name}.csv')        return return_summarydef create_xlsx_ev3(models):    """    Convert CSV evaluation files to formatted XLSX files.        For each model name in the given list, this function reads its evaluation CSV     from the 'model_evaluations_3' directory. The numeric values in the dataframe     are rounded to two decimal places and then saved to XLSX format in the same directory.        Args:        models (list of str): List of model names corresponding to evaluation CSV files.            Returns:        list of pd.DataFrame: A list of transposed dataframes containing the rounded data for each model.        Notes:        - Assumes evaluation files are either named as '<model_name>.csv' or just '<model_name>'          in the 'model_evaluations_3' directory.        - Writes XLSX files named as '00_<model_name>.xlsx' in the 'model_evaluations_3' directory.    """        df_list = []        try:        for i in range(len(models)):            df_list.append(pd.read_csv(f'model_evaluations_3/{models[i]}.csv'))    except:        for i in range(len(models)):            df_list.append(pd.read_csv(f'model_evaluations_3/{models[i]}'))            for df in df_list:        for row in range(len(df.index)):            for col in range(len(df.columns)):                                df.iloc[row, col] = str(round(df.iloc[row, col], 2))                        for i, model_name in enumerate(models):         df_list[i].to_excel(f'model_evaluations_3/00_{model_name}.xlsx')    return df_list.Tdef get_ev1_df_list(models):    """    Retrieve a list of evaluation dataframes from the 'model_evaluations_1' directory.    For each model name in the given list, this function reads its evaluation CSV     from the 'model_evaluations_1' directory, converts the 'Date' column to period     format, and adds the resulting dataframe to a list.        Args:        models (list of str): List of model names corresponding to evaluation CSV files.            Returns:        list of pd.DataFrame: A list of dataframes containing the evaluation data for each model.    Notes:        - Assumes evaluation files are either named as '<model_name>.csv' or just '<model_name>'          in the 'model_evaluations_1' directory.        - The 'Date' column in each dataframe is converted to period format (Month).    """        df_list = []        try:        for i in range(len(models)):            ev1 = pd.read_csv(f'model_evaluations_1/{models[i]}.csv', index_col=0)            ev1['Date'] = pd.to_datetime(ev1['Date'])            ev1['Date'] = ev1['Date'].dt.to_period('M')            df_list.append(ev1)    except:        for i in range(len(models)):            ev1 = pd.read_csv(f'model_evaluations_1/{models[i]}', index_col=0)            ev1['Date'] = pd.to_datetime(ev1['Date'])            ev1['Date'] = ev1['Date'].dt.to_period('M')            df_list.append(ev1)                        return df_list